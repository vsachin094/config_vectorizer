```markdown
# Network Configuration Vectorization and Search

This project provides an end-to-end pipeline to vectorize multi-vendor network device configurations, mask sensitive data, chunk the configs into meaningful sections, generate semantic embeddings using OpenAI’s API, and store them into a Redis vector database for efficient similarity search.

---

## Features

- Supports multiple vendors: Cisco IOS, IOS-XR, NX-OS, Arista EOS, Juniper Junos, HP Comware, and more.
- Masks sensitive secrets (passwords, SNMP communities, keys) for secure processing.
- Splits configs into logical sections:
  - Global settings
  - Interfaces
  - Access Control Lists (ACLs)
  - Routing protocols
- Uses OpenAI embeddings (`text-embedding-3-small`) for semantic vectorization.
- Stores vectors and metadata in Redis Stack with HNSW index for fast similarity search.
- Modular, extensible, and production-ready baseline code.

---

## Project Structure

```
config_vectorizer/
├── config_loader.py   # Load configs from local files, infer device/vendor
├── masking.py         # Mask secrets and normalize config text
├── sectioner.py       # Split config into logical sections based on vendor
├── embeddings.py      # Generate text embeddings using OpenAI API
├── redis_store.py     # Redis vector index creation and ingestion
└── main_ingest.py     # Orchestrates ingestion pipeline end-to-end
```

---

## Usage

1. **Prerequisites**

- Redis Stack with vector search enabled running locally or remotely.
- Python 3.9+ environment.
- Set your `OPENAI_API_KEY` environment variable for OpenAI API access.

2. **Install dependencies**

```
pip install -r requirements.txt
```

3. **Place configs**

Put your device config files (*.conf) in the `./configs` folder. Filename should be `device_name.conf`.

4. **Run ingestion**

```
python main_ingest.py
```

You should see logs indicating processed devices and sections ingested.

---

## Architecture Diagram

```
flowchart TD
    A[Config File System] -->|Load files| B[File Loader Module]
    B -->|Normalize & Mask Secrets| C[Normalization & Masking]
    C -->|Chunk by Vendor Logic| D[Sectioning Module]
    D -->|Embed Sections| E[Embedding Module using OpenAI]
    E -->|Store vectors & metadata| F[Redis Vector Database]
    
    classDef main fill:#f9f,stroke:#333,stroke-width:2px;
    class A,B,C,D,E,F main;
```

---

## Extending and Customization

- Add new vendor parsing logic in `sectioner.py`.
- Implement advanced secret masking rules in `masking.py`.
- Enhance search capabilities by building query interface querying Redis with vector similarity.
- Scale by batching embeddings and Redis pipelining.

---

## Notes

- This tool assumes configs are in text files per device.
- Embedding chunk size is limited to keep API cost and Redis vector size manageable.
- Redis keys are constructed from device, section type, and ID to prevent duplicates and ease retrieval.

---

## License

MIT License

---

## Acknowledgements

- OpenAI for powerful embedding models.
- Redis Stack for fast vector similarity search.
```